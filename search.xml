<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java源码剖析从入门到放弃【类型篇】 — Integer]]></title>
    <url>%2F2017%2F12%2F17%2FJava%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%20%E2%80%94%20Integer%2F</url>
    <content type="text"><![CDATA[文章仅供参考，转载请注明出处: https://cccc0der.github.io/ 前言 Java是一门面向对象的语言，从接触OOP那一刻起，程序员就被告知在OOP的世界中，一切皆是对象。 由此，某书上说程序员是出轨率最高的职业看来也不是没有道理，因为放眼望去，在我们程序员的世界里对象太多了，而我们最怕的也是找不到对象。 在这样的环境下，int,float,double等这样的基本类型单身狗，显然不符合Java特征，那么来看一下Java是如何为这些单身狗设计相应对象的吧。 Number类123456789public abstract class Number implements java.io.Serializable &#123; private static final long serialVersionUID = -8742448824652078965L; public abstract int intValue(); public abstract long longValue(); public abstract float floatValue(); public abstract double doubleValue(); public byte byteValue() &#123; return (byte)intValue(); &#125; public short shortValue() &#123; return (short)intValue(); &#125;&#125; Java的设计者首先为所有的数值类型做了一层抽象，并将所有的基本数值类型方法放到了这个Number类中，这位看官可能要问了：我只要将取值方法的返回值修改为Object类型或者将方法改为泛型方法不就可以了么，为什么要增加这么多方法呢？因为基本类型没有对象啊，单身狗连在程序中都要差一截，这个世界还真是满满的恶意。 在实际使用中，我们也可能想获得一个int值的浮点表示，也可能想取一个小数的整数部分，因此JDK将所有的基本数值类型都放到这个抽象类Number中，而各位机智的看官也一定猜到了Java中所有的数值类都将通过继承Number类进行实现。下面让我们一起来看一下Java是如何为int设计对象的吧。 Integer类定义1public final class Integer extends Number implements Comparable&lt;Integer&gt; 根据类定义可以得出： Integer继承了Number类，并且本身不可被继承。Integer实现了Comparable接口。 上文已经对Number类作了介绍，那么下面让我们结合Integer类成员来了解一下该类的具体实现吧。 Integer类设计Integer类成员变量1234567891011121314/** 序列化标识 */@Native private static final long serialVersionUID = 1360826667806852920L;/** 存放Integer的值 */private final int value;/** Integer的位数 */@Native public static final int SIZE = 32;/** Integer的字节数 */public static final int BYTES = SIZE / Byte.SIZE;/** 32位int可表示的最小值 -2^31 */@Native public static final int MIN_VALUE = 0x80000000;/** 32位int可表示的最大值 2^31-1 */@Native public static final int MAX_VALUE = 0x7fffffff;/** Integer对应的原子类型 */public static final Class&lt;Integer&gt; TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass("int"); Integer类中存放的基本成员变量代码如上，其含义都很直观，这里就不再赘述，其中@Native注解表示该字段可能来自本地常量，了解过JVM结构的看官应该对本地方法区都有所了解，这里就不再展开了。 Integer成员方法构造函数12345678/** 接收int类型参数，直接赋值给value */public Integer(int value) &#123; this.value = value;&#125;/** 接收String类型参数，默认转换为10进制值，非10进制有效数字则抛出异常 */public Integer(String s) throws NumberFormatException &#123; this.value = parseInt(s, 10);&#125; Integer类提供了两种形式的构造函数，分别用于接收int类型和十进制的String类型值，Integer使用parseInt方法来进行字符串到数值的转换。 字符串转整型方法parseInt方法 首先我们来考虑一个问题：给定一个十进制数的字符串12345，如何把它转换为一个对应的整形数呢？负数怎么处理呢？ 设定int result初值为0，然后从头开始挨个读取字符串string中的字符ch，转换为数字num，并使result = result*10 + num。对于负数，再加上判断首位是否为-即可。那来看一下Integer是怎么处理的吧。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** 默认以10进制转换 */public static int parseInt(String s) throws NumberFormatException &#123; return parseInt(s,10);&#125;/** 指定转换进制 */public static int parseInt(String s, int radix) throws NumberFormatException&#123; /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) &#123; throw new NumberFormatException("null"); &#125; /** Character.MIN_RADIX = 2 */ if (radix &lt; Character.MIN_RADIX) &#123; throw new NumberFormatException("radix " + radix + " less than Character.MIN_RADIX"); &#125; /** Character.MAX_RADIX = 36 */ if (radix &gt; Character.MAX_RADIX) &#123; throw new NumberFormatException("radix " + radix + " greater than Character.MAX_RADIX"); &#125; int result = 0; boolean negative = false; int i = 0, len = s.length(); int limit = -Integer.MAX_VALUE; int multmin; int digit; if (len &gt; 0) &#123; char firstChar = s.charAt(0); /** 可能有'+'和'-' */ if (firstChar &lt; '0') &#123; if (firstChar == '-') &#123; negative = true; limit = Integer.MIN_VALUE; &#125; else if (firstChar != '+') throw NumberFormatException.forInputString(s); /** 如果字符串中只有一个'+'或'-' */ if (len == 1) throw NumberFormatException.forInputString(s); i++; &#125; multmin = limit / radix; while (i &lt; len) &#123; /** 通过进行负数计算来避免正数情况下超过32位int最大值 */ digit = Character.digit(s.charAt(i++),radix); if (digit &lt; 0) &#123; throw NumberFormatException.forInputString(s); &#125; /** 如果result已超过可表示的最大数 */ if (result &lt; multmin) &#123; throw NumberFormatException.forInputString(s); &#125; result *= radix; if (result &lt; limit + digit) &#123; throw NumberFormatException.forInputString(s); &#125; result -= digit; &#125; &#125; else &#123; throw NumberFormatException.forInputString(s); &#125; return negative ? result : -result;&#125; Integer的实现与常规的想法没有太大区别，值得注意的是，Integer采用负数做减法的方式，避免了在转换32位最大负数过程中可能产生的溢出问题。 valueOf方法 在parseInt方法中有这样一段注释 WARNING: This method may be invoked early during VM initializationbefore IntegerCache is initialized. Care must be taken to not usethe valueOf method.警告：该方法会在VM初始化时被调用，这时候IntegerCache还没有初始化。一定注意不要使用valueOf方法 接下来让我们看一下valueOf方法和parseInt方法有什么关系吧。12345678public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10));&#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; valueOf方法重载了两种形式，接收String类型参数的方法功能与parseInt基本相同，将一个十进制字符串转换成对应的Integer类型，在其转换的过程中首先调用了parseInt方法将字符串转换位int类型，然后再通过int类型参数的valueOf方法将int转换为Integer对象，这个过程称为装箱。 我们通过javap查看Integer i = 10;编译后的字节码如下：123Code: 0: bipush 10 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 可以看出这一行代码实际执行过程将会被翻译为Integer i = Integer.valueOf(10),因此通常情况下我们会说，可以使用基本类型操作的情况下不要有意将其转换为对象，在转换过程中会增添装箱操作的消耗，同理可以推及到Long，Float等基本类型的包装类。毕竟找个对象不容易，又得花钱又得花心思。 在装箱函数valueOf(int i)中，首先会对i的值判断，如果在IntegerCache.low和IntegerCache.high之间，则会直接返回预存在IntegerCache中的对象，否则才会新建Integer对象。那么IntegerCache是一个什么样的类，该类又做了什么工作呢？1234567891011121314151617181920212223242526272829303132private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; int h = 127; //读取JVM参数中配置的初始值 String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; IntegerCache是Integer中定义的私有内部类，其构造方法设置为private,该类将在第一次被使用时初始化，调用其中的static部分代码，静态代码块将会为-128~127之间的数创建好相应的对象放到缓存里，使得在对valueOf的调用中，缩短对-128~127的装箱时间。在JAVA6的版本以后，IntegerCache.high的值可以通过在JVM的初始化参数中配置-XX:AutoBoxCacheMax=high来指定缓存的最大值。 让我们再回到parseInt中的那段注释，那段注释并不是面向使用者的，而是面向源码开发者的，其意图是警告开发者在修改Java源码的时候注意不要在其中调用valueOf方法。 parseUnsignedInt方法 Integer类设计的真是十分周到，又为我们提供了字符串转为无符号整数的方法parseUnsignedInt。12345678910111213141516171819202122232425262728293031323334353637public static int parseInt(String s) throws NumberFormatException &#123; return parseInt(s,10);&#125;public static int parseUnsignedInt(String s, int radix) throws NumberFormatException &#123; if (s == null) &#123; throw new NumberFormatException("null"); &#125; int len = s.length(); if (len &gt; 0) &#123; char firstChar = s.charAt(0); if (firstChar == '-') &#123; throw new NumberFormatException(String.format("Illegal leading minus sign " + "on unsigned string %s.", s)); &#125; else &#123; // 括号中的条件可以理解为在这样的情况下整数长度必然在32位无符号数之内 if (len &lt;= 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits (radix == 10 &amp;&amp; len &lt;= 9) ) &#123; // Integer.MAX_VALUE in base 10 is 10 digits return parseInt(s, radix); &#125; else &#123; // 对可能超出长度的数调用Long中的parse方法，其逻辑与parseInt方法相同。 long ell = Long.parseLong(s, radix); if ((ell &amp; 0xffff_ffff_0000_0000L) == 0) &#123; return (int) ell; &#125; else &#123; throw new NumberFormatException(String.format("String value %s exceeds " + "range of unsigned int.", s)); &#125; &#125; &#125; &#125; else &#123; throw NumberFormatException.forInputString(s); &#125;&#125; parseUnsignedInt同样提供两种形式，在其具体的实现函数中，值得注意的一点是对长整型的判断(ell &amp; 0xffff_ffff_0000_0000L) == 0。我们知道Integer长度是32位，采取64位表示其最大无符号数为0x0000_0000_ffff_ffffL，即前32位一定为0，因此只要在这个范围内的合法整数，与0xffff_ffff_0000_0000做按位与操作，结果一定是0。高富帅都是玩儿位操作的。 Integer类中常用的String -&gt; int|Integer方法也就介绍完了。还有两个方法分别是：123public static Integer decode(String nm);public static Integer getInteger(String nm);public static Integer getInteger(String nm, int val); decode方法接受以(+|-)+(0|0x|#)开头的八、十和十六进制字符串，内部实现主要是对格式判断，转换过程调用的是valueOf方法。getInteger方法并不是用来进行字符串转换的，而是配合System.setProperty()使用，获取设置的环境值。 总结 Integer提供了parseInt，valueOf，parseUnsignedInt方法供我们转换字符串，后两种的实现基本也都是依赖于parseInt进行的。 parseInt和valueOf区别在于前者返回int，后者为Integer，int -&gt; Integer的过程称为装箱，一般情况下尽量使用基本类型操作，减少装箱消耗。]]></content>
      <categories>
        <category>Java源码剖析从入门到放弃【类型篇】</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码剖析</tag>
      </tags>
  </entry>
</search>
